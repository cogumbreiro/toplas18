---
layout: default
---

<a name="lab10"><h1>Dependency state</h1></a><p>This module defines a resource dependency state, which is easily mapped
  to a GRG. We define a function to generate a WFG from some <span class="inlinecode"><span class="id" title="var">dependencies</span></span> .</p>
<pre class="code"><span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="Brenner.Vars.html#"><span class="id" title="library">Brenner.Vars</span></a>.<br/><span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="Brenner.ResourceDependency.html#"><span class="id" title="library">Brenner.ResourceDependency</span></a>.<br/><span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="library">Aniceto.Project</span>.<br/><span class="id" title="keyword">Set Implicit Arguments</span>.<br/></pre>
<p>The type of map I ranges from resources to sets of tasks.</p>
<pre class="code"><span class="id" title="keyword">Definition</span> <a name="t_impeded_by"><span class="id" title="definition">t_impeded_by</span></a> := <a class="idref" href="Brenner.ResourceDependency.html#Map_EVT.t"><span class="id" title="definition">Map_EVT.t</span></a> <a class="idref" href="Brenner.Vars.html#set_tid"><span class="id" title="definition">set_tid</span></a>.<br/></pre>
<p>The type of map W ranges tasks to sets of resources.</p>
<pre class="code"><span class="id" title="keyword">Definition</span> <a name="t_wait_on"><span class="id" title="definition">t_wait_on</span></a> := <a class="idref" href="Brenner.Vars.html#Map_TID.t"><span class="id" title="definition">Map_TID.t</span></a> <a class="idref" href="Brenner.ResourceDependency.html#set_event"><span class="id" title="definition">set_event</span></a>.<br/></pre>
<p>A dependency state</p>
<pre class="code"><span class="id" title="keyword">Definition</span> <a name="dependencies"><span class="id" title="definition">dependencies</span></a> := (<a class="idref" href="Brenner.DependencyState.html#t_impeded_by"><span class="id" title="definition">t_impeded_by</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">*</span></a> <a class="idref" href="Brenner.DependencyState.html#t_wait_on"><span class="id" title="definition">t_wait_on</span></a>) % <span class="id" title="keyword">type</span>.<br/><span class="id" title="keyword">Definition</span> <a name="get_wait_on"><span class="id" title="definition">get_wait_on</span></a> (<span class="id" title="var">d</span>:<a class="idref" href="Brenner.DependencyState.html#dependencies"><span class="id" title="definition">dependencies</span></a>) : <a class="idref" href="Brenner.DependencyState.html#t_wait_on"><span class="id" title="definition">t_wait_on</span></a> := <a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Datatypes.html#snd"><span class="id" title="definition">snd</span></a> <a class="idref" href="Brenner.DependencyState.html#d"><span class="id" title="variable">d</span></a>.<br/><span class="id" title="keyword">Definition</span> <a name="get_impeded_by"><span class="id" title="definition">get_impeded_by</span></a> (<span class="id" title="var">d</span>:<a class="idref" href="Brenner.DependencyState.html#dependencies"><span class="id" title="definition">dependencies</span></a>) : <a class="idref" href="Brenner.DependencyState.html#t_impeded_by"><span class="id" title="definition">t_impeded_by</span></a> := <a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Datatypes.html#fst"><span class="id" title="definition">fst</span></a> <a class="idref" href="Brenner.DependencyState.html#d"><span class="id" title="variable">d</span></a>.<br/></pre>
<p>A w-edge is an edge in the dependency state such that `e in W(t)`.</p>
<pre class="code"><span class="id" title="keyword">Definition</span> <a name="WDep"><span class="id" title="definition">WDep</span></a> (<span class="id" title="var">w</span>:<a class="idref" href="Brenner.DependencyState.html#t_wait_on"><span class="id" title="definition">t_wait_on</span></a>) (<span class="id" title="var">t</span>:<a class="idref" href="Brenner.Vars.html#tid"><span class="id" title="definition">tid</span></a>) (<span class="id" title="var">e</span>:<a class="idref" href="Brenner.ResourceDependency.html#event"><span class="id" title="definition">event</span></a>) :=<br/>  <a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">exists</span></a> <span class="id" title="var">es</span><a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">,</span></a> <a class="idref" href="Brenner.Vars.html#Map_TID.MapsTo"><span class="id" title="definition">Map_TID.MapsTo</span></a> <a class="idref" href="Brenner.DependencyState.html#t"><span class="id" title="variable">t</span></a> <a class="idref" href="Brenner.DependencyState.html#es"><span class="id" title="variable">es</span></a> <a class="idref" href="Brenner.DependencyState.html#w"><span class="id" title="variable">w</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">/\</span></a> <a class="idref" href="Brenner.ResourceDependency.html#Set_EVT.In"><span class="id" title="definition">Set_EVT.In</span></a> <a class="idref" href="Brenner.DependencyState.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Brenner.DependencyState.html#es"><span class="id" title="variable">es</span></a>.<br/><span class="id" title="keyword">Definition</span> <a name="WEdge"><span class="id" title="definition">WEdge</span></a> <span class="id" title="var">d</span> := (<a class="idref" href="Brenner.DependencyState.html#WDep"><span class="id" title="definition">WDep</span></a> (<a class="idref" href="Brenner.DependencyState.html#get_wait_on"><span class="id" title="definition">get_wait_on</span></a> <a class="idref" href="Brenner.DependencyState.html#d"><span class="id" title="variable">d</span></a>)).<br/><span class="id" title="keyword">Definition</span> <a name="IDep"><span class="id" title="definition">IDep</span></a> (<span class="id" title="var">i</span>:<a class="idref" href="Brenner.DependencyState.html#t_impeded_by"><span class="id" title="definition">t_impeded_by</span></a>) (<span class="id" title="var">e</span>:<a class="idref" href="Brenner.ResourceDependency.html#event"><span class="id" title="definition">event</span></a>) (<span class="id" title="var">t</span>:<a class="idref" href="Brenner.Vars.html#tid"><span class="id" title="definition">tid</span></a>) :=<br/>  <a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">exists</span></a> <span class="id" title="var">ts</span><a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">,</span></a> <a class="idref" href="Brenner.ResourceDependency.html#Map_EVT.MapsTo"><span class="id" title="definition">Map_EVT.MapsTo</span></a> <a class="idref" href="Brenner.DependencyState.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Brenner.DependencyState.html#ts"><span class="id" title="variable">ts</span></a> <a class="idref" href="Brenner.DependencyState.html#i"><span class="id" title="variable">i</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">/\</span></a> <a class="idref" href="Brenner.Vars.html#Set_TID.In"><span class="id" title="definition">Set_TID.In</span></a> <a class="idref" href="Brenner.DependencyState.html#t"><span class="id" title="variable">t</span></a> <a class="idref" href="Brenner.DependencyState.html#ts"><span class="id" title="variable">ts</span></a>.<br/><span class="id" title="keyword">Definition</span> <a name="IEdge"><span class="id" title="definition">IEdge</span></a> <span class="id" title="var">d</span> := (<a class="idref" href="Brenner.DependencyState.html#IDep"><span class="id" title="definition">IDep</span></a> (<a class="idref" href="Brenner.DependencyState.html#get_impeded_by"><span class="id" title="definition">get_impeded_by</span></a> <a class="idref" href="Brenner.DependencyState.html#d"><span class="id" title="variable">d</span></a>)).<br/></pre>
<p>In this section we define the construction of a WFG from a totally deadlocked
  state. More precisely, by definition of <span class="inlinecode"><span class="id" title="var">TotallyDeadlocked</span></span> , every <span class="inlinecode"><span class="id" title="var">t</span></span> waits
  for some event <span class="inlinecode"><span class="id" title="var">e</span></span> that impeded_by some <span class="inlinecode"><span class="id" title="var">t'</span></span> , hence there is an outgoing
  WFG-edge from <span class="inlinecode"><span class="id" title="var">t</span></span> to <span class="inlinecode"><span class="id" title="var">t'</span></span> . Theorem <span class="inlinecode"><span class="id" title="var">all_pos_odegree_impl_cycle</span></span> states
  that a finite graph in which all vertices have outgoing edges includes a cycle.
  To prove this result we need to provide a WFG defined as a list of pairs
  of <span class="inlinecode"><span class="id" title="var">tid</span></span> s that represent the WFG-edges.</p><p>The goal of this section is to define an algorithm that constructs a
  WFG from a given <span class="inlinecode"><span class="id" title="var">state</span></span> . The translation from <span class="inlinecode"><span class="id" title="var">state</span></span> s into WFG proceeds in
  two steps: first, by converting <span class="inlinecode"><span class="id" title="var">state</span></span> s into <span class="inlinecode"><span class="id" title="var">dependencies</span></span> ;
  and then by converting <span class="inlinecode"><span class="id" title="var">depedencies</span></span> into the WFG. The conversion from
  a <span class="inlinecode"><span class="id" title="var">state</span></span> into <span class="inlinecode"><span class="id" title="var">dependencies</span></span> is handled by Theorem <span class="inlinecode"><span class="id" title="var">deps_of_total</span></span> , so in
  this section we only define the second step of translation.</p><p>The <span class="inlinecode"><span class="id" title="var">Project</span></span> module converts maps of sets into list of pairs. Let <span class="inlinecode"><span class="id" title="var">I_Proj</span></span> for maps of type <span class="inlinecode"><span class="id" title="var">impeded_by</span></span> .</p>
<pre class="code"><span class="id" title="keyword">Module</span> <a name="I_Proj"><span class="id" title="module">I_Proj</span></a> := <span class="id" title="module">Project.Project</span> <a class="idref" href="Brenner.ResourceDependency.html#Map_EVT"><span class="id" title="module">Map_EVT</span></a> <a class="idref" href="Brenner.Vars.html#Set_TID"><span class="id" title="module">Set_TID</span></a>.<br/></pre>
<p>Function <span class="inlinecode"><span class="id" title="var">impeded_by_edges</span></span> converts a map of <span class="inlinecode"><span class="id" title="var">impeded_by</span></span> relation into
    a list of pairs.</p>
<pre class="code"><span class="id" title="keyword">Definition</span> <a name="impeded_by_edges"><span class="id" title="definition">impeded_by_edges</span></a> : <a class="idref" href="Brenner.DependencyState.html#t_impeded_by"><span class="id" title="definition">t_impeded_by</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> (<a class="idref" href="Brenner.ResourceDependency.html#event"><span class="id" title="definition">event</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">*</span></a> <a class="idref" href="Brenner.Vars.html#tid"><span class="id" title="definition">tid</span></a>) := <a class="idref" href="Brenner.DependencyState.html#project"><span class="id" title="definition">I_Proj.project</span></a>.<br/></pre>
<p>Lemma <span class="inlinecode"><span class="id" title="var">impeded_by_edges_spec</span></span> establishes the correctness of
    Function <span class="inlinecode"><span class="id" title="var">impeded_by_edges</span></span> : each pair in the outcome of the
    function is in relation <span class="inlinecode"><span class="id" title="var">IEdge</span></span> .</p><p>To prove this result we use Lemma <span class="inlinecode"><span class="id" title="var">Project.edges_spec</span></span> .</p>
<pre class="code"><span class="id" title="keyword">Lemma</span> <a name="impeded_by_edges_spec"><span class="id" title="lemma">impeded_by_edges_spec</span></a>:<br/>  <span class="id" title="keyword">forall</span> <span class="id" title="var">e</span> <span class="id" title="var">t</span> <span class="id" title="var">d</span>,<br/>  <a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Lists.List.html#In"><span class="id" title="definition">List.In</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Brenner.DependencyState.html#e"><span class="id" title="variable">e</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Brenner.DependencyState.html#t"><span class="id" title="variable">t</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> (<a class="idref" href="Brenner.DependencyState.html#impeded_by_edges"><span class="id" title="definition">impeded_by_edges</span></a> (<a class="idref" href="Brenner.DependencyState.html#get_impeded_by"><span class="id" title="definition">get_impeded_by</span></a> <a class="idref" href="Brenner.DependencyState.html#d"><span class="id" title="variable">d</span></a>)) <a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Logic.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">&lt;-&gt;</span></a> <a class="idref" href="Brenner.DependencyState.html#IEdge"><span class="id" title="definition">IEdge</span></a> <a class="idref" href="Brenner.DependencyState.html#d"><span class="id" title="variable">d</span></a> <a class="idref" href="Brenner.DependencyState.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Brenner.DependencyState.html#t"><span class="id" title="variable">t</span></a>.<br/></pre>
<p>Similarly, we project the map I into pairs of tasks and resources.</p>
<pre class="code"><span class="id" title="keyword">Module</span> <a name="W_Proj"><span class="id" title="module">W_Proj</span></a> := <span class="id" title="module">Project.Project</span> <a class="idref" href="Brenner.Vars.html#Map_TID"><span class="id" title="module">Map_TID</span></a> <a class="idref" href="Brenner.ResourceDependency.html#Set_EVT"><span class="id" title="module">Set_EVT</span></a>.<br/><span class="id" title="keyword">Definition</span> <a name="wait_on_edges"><span class="id" title="definition">wait_on_edges</span></a> : <a class="idref" href="Brenner.DependencyState.html#t_wait_on"><span class="id" title="definition">t_wait_on</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> (<a class="idref" href="Brenner.Vars.html#tid"><span class="id" title="definition">tid</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">*</span></a> <a class="idref" href="Brenner.ResourceDependency.html#event"><span class="id" title="definition">event</span></a>) := <a class="idref" href="Brenner.DependencyState.html#project"><span class="id" title="definition">W_Proj.project</span></a>.<br/></pre>
<p>By using lemma <span class="inlinecode"><span class="id" title="var">Project.edges_spec</span></span> , we get that any pair
    in <span class="inlinecode"><span class="id" title="var">wait_on_edges</span></span> is a <span class="inlinecode"><span class="id" title="var">WEdge</span></span> (aka impeded_by relation).</p>
<pre class="code"><span class="id" title="keyword">Lemma</span> <a name="wait_on_edges_spec"><span class="id" title="lemma">wait_on_edges_spec</span></a>:<br/>  <span class="id" title="keyword">forall</span> <span class="id" title="var">t</span> <span class="id" title="var">e</span> <span class="id" title="var">d</span>,<br/>  <a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Lists.List.html#In"><span class="id" title="definition">List.In</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Brenner.DependencyState.html#t"><span class="id" title="variable">t</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Brenner.DependencyState.html#e"><span class="id" title="variable">e</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> (<a class="idref" href="Brenner.DependencyState.html#wait_on_edges"><span class="id" title="definition">wait_on_edges</span></a> (<a class="idref" href="Brenner.DependencyState.html#get_wait_on"><span class="id" title="definition">get_wait_on</span></a> <a class="idref" href="Brenner.DependencyState.html#d"><span class="id" title="variable">d</span></a>)) <a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Logic.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">&lt;-&gt;</span></a> <a class="idref" href="Brenner.DependencyState.html#WEdge"><span class="id" title="definition">WEdge</span></a> <a class="idref" href="Brenner.DependencyState.html#d"><span class="id" title="variable">d</span></a> <a class="idref" href="Brenner.DependencyState.html#t"><span class="id" title="variable">t</span></a> <a class="idref" href="Brenner.DependencyState.html#e"><span class="id" title="variable">e</span></a>.<br/><span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Lists.List.html#"><span class="id" title="library">Coq.Lists.List</span></a>.<br/><span class="id" title="keyword">Definition</span> <a name="WFGEdge"><span class="id" title="definition">WFGEdge</span></a> <span class="id" title="var">d</span> <span class="id" title="var">t</span> <span class="id" title="var">t'</span> := <a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">exists</span></a> <span class="id" title="var">e</span><a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">,</span></a> <a class="idref" href="Brenner.DependencyState.html#WEdge"><span class="id" title="definition">WEdge</span></a> <a class="idref" href="Brenner.DependencyState.html#d"><span class="id" title="variable">d</span></a> <a class="idref" href="Brenner.DependencyState.html#t"><span class="id" title="variable">t</span></a> <a class="idref" href="Brenner.DependencyState.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">/\</span></a> <a class="idref" href="Brenner.DependencyState.html#IEdge"><span class="id" title="definition">IEdge</span></a> <a class="idref" href="Brenner.DependencyState.html#d"><span class="id" title="variable">d</span></a> <a class="idref" href="Brenner.DependencyState.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Brenner.DependencyState.html#t'"><span class="id" title="variable">t'</span></a>.<br/></pre>
<p>Given the impeded_by of a dependency state <span class="inlinecode"><span class="id" title="var">d</span></span> , filter the edges
    matching <span class="inlinecode"><span class="id" title="var">e</span></span> .</p>
<pre class="code"><span class="id" title="keyword">Definition</span> <a name="impeded_by_matching"><span class="id" title="definition">impeded_by_matching</span></a> <span class="id" title="var">d</span> <span class="id" title="var">e</span> := <br/>  <a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Lists.List.html#filter"><span class="id" title="definition">filter</span></a><br/>  (<span class="id" title="keyword">fun</span> <span class="id" title="var">edge</span>:(<a class="idref" href="Brenner.ResourceDependency.html#event"><span class="id" title="definition">event</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">*</span></a><a class="idref" href="Brenner.Vars.html#tid"><span class="id" title="definition">tid</span></a>)=&gt;<br/>    <span class="id" title="keyword">let</span> (<span class="id" title="var">e'</span>, <span class="id" title="var">t</span>) := <a class="idref" href="Brenner.DependencyState.html#edge"><span class="id" title="variable">edge</span></a> <span class="id" title="tactic">in</span><br/>    <span class="id" title="keyword">if</span> <a class="idref" href="Brenner.ResourceDependency.html#EVT.eq_dec"><span class="id" title="axiom">EVT.eq_dec</span></a> <a class="idref" href="Brenner.DependencyState.html#e'"><span class="id" title="variable">e'</span></a> <a class="idref" href="Brenner.DependencyState.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="keyword">then</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a> <span class="id" title="keyword">else</span> <a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a>)<br/>  (<a class="idref" href="Brenner.DependencyState.html#impeded_by_edges"><span class="id" title="definition">impeded_by_edges</span></a> (<a class="idref" href="Brenner.DependencyState.html#get_impeded_by"><span class="id" title="definition">get_impeded_by</span></a> <a class="idref" href="Brenner.DependencyState.html#d"><span class="id" title="variable">d</span></a>)).<br/></pre>
<p>Given a task <span class="inlinecode"><span class="id" title="var">t</span></span> waiting for event <span class="inlinecode"><span class="id" title="var">e</span></span> , compute WEdges starting
    from <span class="inlinecode"><span class="id" title="var">t</span></span> . The definition uses function <span class="inlinecode"><span class="id" title="var">impeded_by_matching</span></span> .</p>
<pre class="code"><span class="id" title="keyword">Definition</span> <a name="build_edges"><span class="id" title="definition">build_edges</span></a> (<span class="id" title="var">d</span>:<a class="idref" href="Brenner.DependencyState.html#dependencies"><span class="id" title="definition">dependencies</span></a>) (<span class="id" title="var">edge</span>:(<a class="idref" href="Brenner.Vars.html#tid"><span class="id" title="definition">tid</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">*</span></a><a class="idref" href="Brenner.ResourceDependency.html#event"><span class="id" title="definition">event</span></a>)) : <a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> (<a class="idref" href="Brenner.Vars.html#tid"><span class="id" title="definition">tid</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">*</span></a><a class="idref" href="Brenner.Vars.html#tid"><span class="id" title="definition">tid</span></a>) :=<br/>  <span class="id" title="keyword">let</span> (<span class="id" title="var">t</span>, <span class="id" title="var">e</span>) := <a class="idref" href="Brenner.DependencyState.html#edge"><span class="id" title="variable">edge</span></a> <span class="id" title="tactic">in</span><br/>  <a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Lists.List.html#map"><span class="id" title="definition">map</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">edge'</span>:(<a class="idref" href="Brenner.ResourceDependency.html#event"><span class="id" title="definition">event</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">*</span></a><a class="idref" href="Brenner.Vars.html#tid"><span class="id" title="definition">tid</span></a>)=&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Brenner.DependencyState.html#t"><span class="id" title="variable">t</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Datatypes.html#snd"><span class="id" title="definition">snd</span></a> <a class="idref" href="Brenner.DependencyState.html#edge'"><span class="id" title="variable">edge'</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a>) (<a class="idref" href="Brenner.DependencyState.html#impeded_by_matching"><span class="id" title="definition">impeded_by_matching</span></a> <a class="idref" href="Brenner.DependencyState.html#d"><span class="id" title="variable">d</span></a> <a class="idref" href="Brenner.DependencyState.html#e"><span class="id" title="variable">e</span></a>).<br/></pre>
<p>For each blocked tasks in the dependency state compute the WEdges
    using function <span class="inlinecode"><span class="id" title="var">build_edges</span></span> .</p>
<pre class="code"><span class="id" title="keyword">Definition</span> <a name="build_wfg"><span class="id" title="definition">build_wfg</span></a> (<span class="id" title="var">d</span>:<a class="idref" href="Brenner.DependencyState.html#dependencies"><span class="id" title="definition">dependencies</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> (<a class="idref" href="Brenner.Vars.html#tid"><span class="id" title="definition">tid</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">*</span></a><a class="idref" href="Brenner.Vars.html#tid"><span class="id" title="definition">tid</span></a>) :=<br/>  <a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Lists.List.html#flat_map"><span class="id" title="definition">flat_map</span></a> (<a class="idref" href="Brenner.DependencyState.html#build_edges"><span class="id" title="definition">build_edges</span></a> <a class="idref" href="Brenner.DependencyState.html#d"><span class="id" title="variable">d</span></a>) (<a class="idref" href="Brenner.DependencyState.html#wait_on_edges"><span class="id" title="definition">wait_on_edges</span></a> (<a class="idref" href="Brenner.DependencyState.html#get_wait_on"><span class="id" title="definition">get_wait_on</span></a> <a class="idref" href="Brenner.DependencyState.html#d"><span class="id" title="variable">d</span></a>)).<br/></pre>
<p>The first main result is to show that any pair in <span class="inlinecode"><span class="id" title="var">build_wfg</span></span> is a <span class="inlinecode"><span class="id" title="var">WEdge</span></span> . The proof uses lemmas <span class="inlinecode"><span class="id" title="var">wait_on_edges_spec</span></span> and <span class="inlinecode"><span class="id" title="var">impeded_by_edges_spec</span></span> .</p>
<pre class="code"><span class="id" title="keyword">Theorem</span> <a name="build_wfg_spec"><span class="id" title="lemma">build_wfg_spec</span></a>:<br/>  <span class="id" title="keyword">forall</span> <span class="id" title="var">d</span> <span class="id" title="var">t</span> <span class="id" title="var">t'</span>,<br/>  <a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Lists.List.html#In"><span class="id" title="definition">List.In</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Brenner.DependencyState.html#t"><span class="id" title="variable">t</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Brenner.DependencyState.html#t'"><span class="id" title="variable">t'</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> (<a class="idref" href="Brenner.DependencyState.html#build_wfg"><span class="id" title="definition">build_wfg</span></a> <a class="idref" href="Brenner.DependencyState.html#d"><span class="id" title="variable">d</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Logic.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">&lt;-&gt;</span></a> <a class="idref" href="Brenner.DependencyState.html#WFGEdge"><span class="id" title="definition">WFGEdge</span></a> <a class="idref" href="Brenner.DependencyState.html#d"><span class="id" title="variable">d</span></a> <a class="idref" href="Brenner.DependencyState.html#t"><span class="id" title="variable">t</span></a> <a class="idref" href="Brenner.DependencyState.html#t'"><span class="id" title="variable">t'</span></a>.<br/></pre>
<p>Let <span class="inlinecode"><span class="id" title="var">WFG_of</span></span> be the definition of a finite WFG defined
    as a sequence of edges.</p>
<pre class="code"><span class="id" title="keyword">Definition</span> <a name="WFG_of"><span class="id" title="definition">WFG_of</span></a> <span class="id" title="var">d</span> <span class="id" title="var">wfg</span> := <br/>  <span class="id" title="keyword">forall</span> <span class="id" title="var">t</span> <span class="id" title="var">t'</span>, <a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Lists.List.html#In"><span class="id" title="definition">List.In</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Brenner.DependencyState.html#t"><span class="id" title="variable">t</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <a class="idref" href="Brenner.DependencyState.html#t'"><span class="id" title="variable">t'</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> <a class="idref" href="Brenner.DependencyState.html#wfg"><span class="id" title="variable">wfg</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Logic.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">&lt;-&gt;</span></a> <a class="idref" href="Brenner.DependencyState.html#WFGEdge"><span class="id" title="definition">WFGEdge</span></a> <a class="idref" href="Brenner.DependencyState.html#d"><span class="id" title="variable">d</span></a> <a class="idref" href="Brenner.DependencyState.html#t"><span class="id" title="variable">t</span></a> <a class="idref" href="Brenner.DependencyState.html#t'"><span class="id" title="variable">t'</span></a>.<br/></pre>
<p>Given <span class="inlinecode"><span class="id" title="var">build_wfg_spec</span></span> it is easy to show that we can
    always obtain a finite WFG from a dependency state <span class="inlinecode"><span class="id" title="var">d</span></span> .</p>
<pre class="code"><span class="id" title="keyword">Corollary</span> <a name="wfg_of_total"><span class="id" title="lemma">wfg_of_total</span></a>:<br/>  <span class="id" title="keyword">forall</span> <span class="id" title="var">d</span>:<a class="idref" href="Brenner.DependencyState.html#dependencies"><span class="id" title="definition">dependencies</span></a>, <a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">exists</span></a> <span class="id" title="var">wfg</span><a class="idref" href="http://coq.inria.fr/distrib/8.7.1/stdlib//Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">,</span></a> <a class="idref" href="Brenner.DependencyState.html#WFG_of"><span class="id" title="definition">WFG_of</span></a> <a class="idref" href="Brenner.DependencyState.html#d"><span class="id" title="variable">d</span></a> <a class="idref" href="Brenner.DependencyState.html#wfg"><span class="id" title="variable">wfg</span></a>.<br/></pre>
